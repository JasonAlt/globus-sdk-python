from __future__ import annotations

from globus_sdk.exc import GlobusAPIError

"""
Errors generated by Timer itself look like this:

.. code-block:: json

    {
        "error": {
            "code": "ERROR",
            "detail": "Request failed successfully",
            "status": 500
        }
    }


While errors from Timer's pydantic implementation look like this:

.. code-block:: json

    {
        "detail": [
            {
                "loc": ["body", "start"],
                "msg": "field required",
                "type": "value_error.missing"
            },
            {
                "loc": ["body", "callback_url"],
                "msg": "field required",
                "type": "value_error.missing"
            },
            ...

The ``msg`` might be like the above, or "value is not a valid <TYPE>", and so
on.  ``loc`` however is always a list which indicates the location of the error
within the request. It might say ``["body", "start"]`` for example, or it might
start with "query" to point to a value in the query string.
"""


class TimerAPIError(GlobusAPIError):
    """
    Error class to represent error responses from Timer.

    Has no particular additions to the base ``GlobusAPIError``, but implements a
    different method for parsing error responses from Timer due to the differences
    between pydantic-generated errors and other errors.
    """

    def _parse_errors_array(self) -> None:
        """
        Treat any top-level "error" key as an "array of size 1".
        Meaning that we'll see a single subdocument for data shaped like
            {
              "error": {
                "foo": "bar"
              }
            }
        """
        if isinstance(self._dict_data.get("error"), dict):
            self.errors = [self._dict_data["error"]]
        else:
            return super()._parse_errors_array()

    def _parse_code(self) -> None:
        if isinstance(self._dict_data.get("detail"), list):
            self.code = "Validation Error"
        else:
            super()._parse_code()

    def _parse_messages(self) -> None:
        if isinstance(self._dict_data.get("detail"), list):
            self.messages.extend(
                [
                    e["msg"] + ": " + ".".join(k for k in e["loc"])
                    for e in self._dict_data["detail"]
                ]
            )
        else:
            super()._parse_messages()
